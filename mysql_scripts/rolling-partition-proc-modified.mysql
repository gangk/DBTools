CREATE TABLE `yms_events_data_test2` (
  `node_id` varchar(5) NOT NULL,
  `yard_code` varchar(10) DEFAULT NULL,
  `event_type` varchar(45) NOT NULL,
  `count_of_events` int(11) DEFAULT NULL,
  `event_date` datetime DEFAULT NULL,
  `actioned_by` varchar(45) DEFAULT NULL,
  `created_by` varchar(512) NOT NULL,
  `partition_key` datetime NOT NULL,
  `region_id` int(11) NOT NULL,
  PRIMARY KEY (`partition_key`,`created_by`,`node_id`,`event_type`),
  KEY `yms_partition_key_event_type_node_id_idx` (`partition_key`,`event_type`,`node_id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
PARTITION BY RANGE (TO_DAYS(partition_key))
(PARTITION chaos_2019_02_20 VALUES LESS THAN (737476) ENGINE = InnoDB,
 PARTITION chaos_2019_02_21 VALUES LESS THAN (737477) ENGINE = InnoDB);
 
 
DELIMITER //
CREATE DEFINER=`sad_application`@`%` PROCEDURE `partition_create` (SCHEMANAME VARCHAR(64), TABLENAME VARCHAR(64), PARTITIONNAME VARCHAR(64), PARTITION_KEY INT)
BEGIN
        DECLARE RETROWS INT;
        SELECT COUNT(1) INTO RETROWS
        FROM information_schema.partitions
        WHERE table_schema = SCHEMANAME
      AND TABLE_NAME = TABLENAME
      AND partition_name = PARTITIONNAME;
        IF RETROWS = 0 THEN
 
                SELECT CONCAT( "partition_create(", SCHEMANAME, ",", TABLENAME, ",", PARTITIONNAME, ",",PARTITION_KEY,")" ) AS msg;
                SET @SQL = CONCAT( 'ALTER TABLE ', SCHEMANAME, '.', TABLENAME, ' ADD PARTITION (PARTITION ', PARTITIONNAME, ' VALUES LESS THAN (',PARTITION_KEY,'));' );
                PREPARE STMT FROM @SQL;
                EXECUTE STMT;
                DEALLOCATE PREPARE STMT;
        END IF;
END//
 
 
 
DELIMITER //
CREATE DEFINER=`sad_application`@`%` PROCEDURE `partition_drop`(SCHEMANAME VARCHAR(64), TABLENAME VARCHAR(64), DELETE_BELOW_PARTITION_DATE VARCHAR(16))
BEGIN
 
        DECLARE done INT DEFAULT FALSE;
        DECLARE drop_part_name VARCHAR(16);
        
 
        DECLARE myCursor CURSOR FOR
                SELECT partition_name
                FROM information_schema.partitions
                WHERE table_schema = SCHEMANAME AND TABLE_NAME = TABLENAME AND SUBSTRING(partition_name FROM 7) < DELETE_BELOW_PARTITION_DATE;
        DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
         
        SET @alter_header = CONCAT("ALTER TABLE ", SCHEMANAME, ".", TABLENAME, " DROP PARTITION ");
        SET @drop_partitions = "";
 
 
        OPEN myCursor;
        read_loop: LOOP
                FETCH myCursor INTO drop_part_name;
                IF done THEN
                        LEAVE read_loop;
                END IF;
                SET @drop_partitions = IF(@drop_partitions = "", drop_part_name, CONCAT(@drop_partitions, ",", drop_part_name));
        END LOOP;
        SELECT @drop_partitions as Drop_partitions;
        IF @drop_partitions != "" THEN
 
                SET @full_sql = CONCAT(@alter_header, @drop_partitions, ";");
                PREPARE STMT FROM @full_sql;
                EXECUTE STMT;
                DEALLOCATE PREPARE STMT;
 
                SELECT CONCAT(SCHEMANAME, ".", TABLENAME) AS `table`, @drop_partitions AS `partitions_deleted`;
        ELSE
 
                SELECT CONCAT(SCHEMANAME, ".", TABLENAME) AS `table`, "N/A" AS `partitions_deleted`;
        END IF;
END//
 
 
 
DELIMITER //
CREATE DEFINER=`sad_application`@`%` PROCEDURE `partition_maintenance`(SCHEMA_NAME VARCHAR(64), TABLE_NAME VARCHAR(64), KEEP_DATA_DAYS INT, CREATE_NEXT_INTERVALS INT)
BEGIN
        DECLARE OLDER_THAN_PARTITION_DATE VARCHAR(16);  
        DECLARE PARTITION_NAME VARCHAR(16);
        DECLARE PARTITION_KEY INT;      
        DECLARE CUR_TIME INT;
        DECLARE PARTITION_DATE DATE;
        
        SET CUR_TIME = UNIX_TIMESTAMP(DATE_FORMAT(NOW(), '%Y-%m-%d 00:00:00')); -- seconds since 1970-01-01 00:00:00' UTC
        SET PARTITION_KEY = TO_DAYS(CURDATE());
        SET PARTITION_DATE = DATE_FORMAT(NOW(), '%Y-%m-%d');
        IF DATE(NOW()) = '2014-04-01' THEN 
                SET CUR_TIME = UNIX_TIMESTAMP(DATE_FORMAT(DATE_ADD(NOW(), INTERVAL 1 DAY), '%Y-%m-%d 00:00:00'));   
        END IF;
        SET @__interval = 1;
        create_loop: LOOP
                IF @__interval > CREATE_NEXT_INTERVALS THEN
                        LEAVE create_loop;
                END IF;
 
 
                SET PARTITION_NAME = DATE_FORMAT(DATE_SUB(PARTITION_DATE,INTERVAL 1 DAY),'chaos_%Y_%m_%d');  
                
 
                CALL partition_create(SCHEMA_NAME, TABLE_NAME, PARTITION_NAME, PARTITION_KEY);
                SET PARTITION_KEY = TO_DAYS(DATE_ADD(CURDATE(), INTERVAL (@__interval) DAY));
                SET PARTITION_DATE = DATE_FORMAT(DATE_ADD(NOW(),INTERVAL (@__interval) DAY),'%Y-%m-%d');
                SET @__interval=@__interval + 1;
 
        END LOOP;
 
        SET OLDER_THAN_PARTITION_DATE=DATE_FORMAT(DATE_SUB(NOW(), INTERVAL KEEP_DATA_DAYS DAY), '%Y_%m_%d');
        CALL partition_drop(SCHEMA_NAME, TABLE_NAME, OLDER_THAN_PARTITION_DATE);
 
END//
 
 
 
DELIMITER //
CREATE DEFINER=`sad_application`@`%` PROCEDURE `partition_maintenance_all`(SCHEMA_NAME VARCHAR(32))
BEGIN
CALL partition_maintenance(SCHEMA_NAME,'sad_metric_value',250,15);
CALL partition_maintenance(SCHEMA_NAME,'sad_metric_value1548303096',250,15);
CALL partition_maintenance(SCHEMA_NAME,'sad_metric_value1548304687',250,15);
CALL partition_maintenance(SCHEMA_NAME,'sad_metric_value1548319689',250,15);
CALL partition_maintenance(SCHEMA_NAME,'sad_metric_value1549969146',250,15);
CALL partition_maintenance(SCHEMA_NAME,'sad_metric_value_temp',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_adhoc_load_request_data_old',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_cancelled_adhoc_load_request_data_old',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_chb_unmanifested_data',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_chb_unmanifested_data1550691798',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_chb_unmanifested_data1550692738',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_chb_unmanifested_data1550693306',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_chb_unmanifested_data1550697297',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_container_audit_tool_usage_data',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_container_audit_tool_usage_data1550653623',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_container_info_tool_usage_data',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_corrected_failed_moves_data',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_failed_moves_data',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_first_time_scan_success_data',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_missed_cpt_data',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_missed_loading_scan_data_D21022019',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_missed_stacking_scan_data_backup',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_missed_staging_scan_data1550596872',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_package_to_package_scan_data_test',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_pkg_to_dropzone_request_data',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_sweep_pkg_data',250,15);
CALL partition_maintenance(SCHEMA_NAME,'ssp_water_spider_scan_data',250,15);
CALL partition_maintenance(SCHEMA_NAME,'yms_events_data',250,15);

END//
 
DELIMITER //
CREATE DEFINER=`sad_application`@`%` PROCEDURE `partition_verify`(SCHEMANAME VARCHAR(64), TABLENAME VARCHAR(64), HOURLYINTERVAL INT(11))
BEGIN
        DECLARE PARTITION_NAME VARCHAR(16);
        DECLARE RETROWS INT(11);
        DECLARE FUTURE_TIMESTAMP TIMESTAMP;
 
 
        SELECT COUNT(1) INTO RETROWS
        FROM information_schema.partitions
        WHERE table_schema = SCHEMANAME AND TABLE_NAME = TABLENAME AND partition_name IS NULL;
 
 
        IF RETROWS = 1 THEN
 
                SET FUTURE_TIMESTAMP = TIMESTAMPADD(HOUR, HOURLYINTERVAL, CONCAT(CURDATE(), " ", '00:00:00'));
                SET PARTITION_NAME = DATE_FORMAT(CURDATE(), 'DAILY_%Y%m%d');
 
 
                SET @__PARTITION_SQL = CONCAT("ALTER TABLE ", SCHEMANAME, ".", TABLENAME, " PARTITION BY RANGE(UNIX_TIMESTAMP(partition_key))");
                SET @__PARTITION_SQL = CONCAT(@__PARTITION_SQL, "(PARTITION ", PARTITION_NAME, " VALUES LESS THAN (", UNIX_TIMESTAMP(FUTURE_TIMESTAMP), "));");
 
 
                PREPARE STMT FROM @__PARTITION_SQL;
                EXECUTE STMT;
                DEALLOCATE PREPARE STMT;
        END IF;
END//
 
 
 
-- ==> Job Scheduling(utc)
CREATE DEFINER=`sad_application`@`%` EVENT `entropy_partition_event` ON SCHEDULE EVERY 1 DAY STARTS '2019-02-27 19:45:00' ON COMPLETION NOT PRESERVE ENABLE DO CALL alti_sad.partition_maintenance_all('alti_sad');
 
 
 
/*
drop PROCEDURE IF EXISTS partition_maintenance_all;
drop PROCEDURE IF EXISTS partition_create;
drop PROCEDURE IF EXISTS partition_drop;
drop PROCEDURE IF EXISTS partition_maintenance;
commit;
*/
